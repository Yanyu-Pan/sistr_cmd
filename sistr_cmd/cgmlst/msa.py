from subprocess import PIPE, Popen

from typing import Union, List, Dict

MSA_GAP_PROP_THRESHOLD = 0.05

MAFFT_INPUT_FORMAT = """>ref
{}
>novel
{}
"""


def parse_aln_out(out):
    lines = out.split('\n')
    seqs = []
    header = ''
    for line in lines:
        line = line.strip()
        if line == '': continue
        if line[0] == '>':
            if header == '':
                header = line.replace('>','')
            else:
                yield header, ''.join(seqs)
                seqs = []
                header = line.replace('>','')
        else:
            seqs.append(line)
    yield header, ''.join(seqs)


def msa_mafft(seqs: Union[str, List[str], Dict[str, str]]) -> Union[str, List[str], Dict[str, str]]:
    if isinstance(seqs, list):
        mafft_stdin = '\n'.join(['>{}\n{}'.format(i, x.lower()) for i, x in enumerate(seqs)])
    elif isinstance(seqs, dict):
        mafft_stdin = '\n'.join(['>{}\n{}'.format(k, v.lower()) for k, v in seqs.items()])
    elif isinstance(seqs, (str,)):
        mafft_stdin = seqs
    else:
        raise Exception('Unexpected type for param seqs of "{}"'.format(type(seqs)))

    p = Popen(['mafft', '-'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
    stdout, stderr = p.communicate(input=mafft_stdin.encode())
    if isinstance(stdout, bytes):
        stdout = stdout.decode()
    if stdout[0] == '>':
        if isinstance(seqs, list):
            return [s for h,s in parse_aln_out(stdout)]
        elif isinstance(seqs, (dict, str)):
            return {h:s for h,s in parse_aln_out(stdout)}
    else:
        raise Exception('MSA not generated by MAFFT stdout=\n{}\n\nstderr=\n{}\n'.format(stdout, stderr))



def msa_ref_vs_novel(ref_seq: str, novel_seq: str):
    input_fasta = MAFFT_INPUT_FORMAT.format(ref_seq.lower(), novel_seq.lower())
    msa_out_dict = msa_mafft(input_fasta)
    assert 'ref' in msa_out_dict
    assert 'novel' in msa_out_dict
    return msa_out_dict['ref'], msa_out_dict['novel']


def number_gapped_ungapped(aln1, aln2):
    assert len(aln1) == len(aln2)
    ungapped = 0
    gapped_aln1 = 0
    gapped_aln2 = 0
    for c1, c2 in zip(aln1, aln2):
        if c1 == '-' and c2 == '-':
            continue
        if c1 == '-':
            gapped_aln1 += 1
        elif c2 == '-':
            gapped_aln2 += 1
        else:
            ungapped += 1

    return (gapped_aln1 + gapped_aln2), ungapped